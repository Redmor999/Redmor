## 重新排列单词间的空格

给你一个字符串 text ，该字符串由若干被空格包围的单词组成。每个单词由一个或者多个小写英文字母组成，并且两个单词之间至少存在一个空格。题目测试用例保证 text 至少包含一个单词 。

请你重新排列空格，使每对相邻单词之间的空格数目都 相等 ，并尽可能 最大化 该数目。如果不能重新平均分配所有空格，请 将多余的空格放置在字符串末尾 ，这也意味着返回的字符串应当与原 text 字符串的长度相等。

返回 重新排列空格后的字符串 。

**问题分析：**

一般解法对于C++语言来说太过麻烦困难，要先对字符串进行split切分，C++没有splitAPI函数。

**双指针法思想**

具体上：将所有非空格先换到最后，算出空格的需求，再根据需求将非空格字符换回

抽象上：设计两个快慢指针，快指针用来寻找下一个操作的目标，慢指针用来标定放置的位置

```C++
class Solution{
public
	string reorderSpaces(string s){
    	int n = s.size();	//字符串长度
    	cnt = n, m = 0;		//cnt记录空格的个数，m为非空格字串个数统计
    	//此循环实现非空格字串放在最后，并记录字串数量和空格数量
    	for(int i = n-1, j = n-1, f = false; i >=0; --i)
        {
            if(s[i]!=' ')
            {
                swap(s[i], s[j--]);	//字符交换，下标i为快指针，j为慢指针
                m += !f;	//记录字串数量
                f = true;	//f为真，表明快指针在某一字串中
                --cnt;		//确定空格数量
            }
            else if(f) 
            {
                --j, f = false;	//快指针指向空格，并且f为真，要把f置为假并前移，
            }
        }
    	
    	for(int i= 0, j = 0, f =false, a = cnt/max(m-1, 1); i<n; i++)
        {
            if(s[i] != ' ')
            {
            	swap(s[i], s[j++]);
            	f = true; 
            } 
            else if(f)
            {
                j += a, f = false;
            }
            
		}
    	return s;
	}
}
```

